/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GlobalProxyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

const DEFAULT_SETTINGS = {
    enableProxy: false,
    httpProxy: "",
	httpsProxy: "",
	socksProxy: ""
};

var GlobalProxyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new GlobalProxySettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
	this.setGlobalProxy();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  
  async setGlobalProxy() {
	  if (this.settings.enableProxy) {
			let proxyRules;
			try {
			  proxyRules = this.composeProxyRules();
			} catch(ex) {
				new import_obsidian.Notice(ex.message);
				return;
			}
			
			try {
				await electron.remote.session.defaultSession.setProxy({ proxyRules }); 
				new import_obsidian.Notice('Global proxy set successfully');
			} catch (ex) {
				new import_obsidian.Notice('Global proxy set failed');
				console.error("ex.message");
			}
	  } else {
			try {
				const session = electron.remote.session.defaultSession
				await session.setProxy({});
				await session.closeAllConnections();
				new import_obsidian.Notice('Disable global proxy');
			} catch (ex) {
				new import_obsidian.Notice('Disable global proxy failed');
				console.error("ex.message");
			}
	  }
	}
	
	composeProxyRules() {
		const httpProxy= isValidFormat(this.settings.httpProxy) ? ";http=" + this.settings.httpProxy : "";
		const httpsProxy= isValidFormat(this.settings.httpsProxy) ? ";https=" + this.settings.httpsProxy : "";
		if (isValidFormat(this.settings.socksProxy)) {
			return this.settings.socksProxy + httpProxy + httpsProxy + ",direct://"
		} else if (!!httpProxy) {
			return !!httpsProxy ? "http=" + this.settings.httpProxy + httpsProxy + ",direct://"
				: this.settings.httpProxy + ",direct://"
		} else if (!!httpsProxy) {
			return this.settings.httpsProxy + ",direct://"
		} else {
			throw new Error("No valid proxy")
		}
	}
};

var GlobalProxySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
	new import_obsidian.Setting(containerEl)
	.setName("Enable proxy")
	.setDesc("Change your proxy status")
	.addToggle((val) => val
	.setValue(this.plugin.settings.enableProxy)
	.onChange(async (value) =>  {
		this.plugin.settings.enableProxy = value;
		await this.plugin.saveSettings();
		this.plugin.setGlobalProxy();
    }));
	new import_obsidian.Setting(containerEl)
	.setName("Socks Proxy")
	.setDesc("Set up your socks proxy")
	.addText((text) => text
	.setPlaceholder("<scheme>://<host>:<port>")
	.setValue(this.plugin.settings.socksProxy)
	.onChange((value) => {
      this.refreshProxy("socksProxy", value); 
    }));
	new import_obsidian.Setting(containerEl)
	.setName("Http Proxy")
	.setDesc("Set up your http proxy")
	.addText((text) => text
	.setPlaceholder("<scheme>://<host>:<port>")
	.setValue(this.plugin.settings.httpProxy)
	.onChange((value) => {
	  this.refreshProxy("httpProxy", value); 
    }));
	new import_obsidian.Setting(containerEl)
	.setName("Https Proxy")
	.setDesc("Set up your https proxy")
	.addText((text) => text
	.setPlaceholder("<scheme>://<host>:<port>")
	.setValue(this.plugin.settings.httpsProxy)
	.onChange((value) => {
	  this.refreshProxy("httpsProxy", value);      
    }));
  }
  async refreshProxy(key, value) {
	  if (isValidFormat(value)) {
		this.plugin.settings[key] = value;
		await this.plugin.saveSettings();
		this.plugin.setGlobalProxy(); 
	  }
  }	
};


function isValidFormat(proxyUrl) {
  if (!!proxyUrl) {
	  const regex = /^(\w+):\/\/([^:/]+):(\d+)$/;
	  const matches = proxyUrl.match(regex);
	  return !!matches;
  }
  return false;
}
